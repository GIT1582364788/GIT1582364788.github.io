(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{192:function(e,t,n){"use strict";n.r(t);var r=n(0),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[e._m(0),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),n("p",[e._v("是通过Object.defineProperty()来拦截数据，将数据转换成getter/setter的形式，在访问数据时调用getter函数，在修改数据时调用setter函数。然后利用发布-订阅模式，在数据变动时触发依赖，也即发布更新给订阅者，订阅者收到消息后进行相应的处理。")]),e._v(" "),n("p",[e._v("Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象")]),e._v(" "),e._m(8),e._m(9),e._m(10),e._m(11),e._v(" "),e._m(12),e._v(" "),n("p",[e._v("ES6新增Proxy "),n("a",{attrs:{href:"https://es6.ruanyifeng.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("es6阮一峰"),n("OutboundLink")],1)]),e._v(" "),e._m(13),e._v(" "),e._m(14),e._v(" "),e._m(15),e._v(" "),e._m(16),e._m(17),n("p",[e._v("总结：")]),e._v(" "),e._m(18)])}),[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"前端知识点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端知识点"}},[this._v("#")]),this._v(" 前端知识点")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"html"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#html"}},[this._v("#")]),this._v(" Html")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"css"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[this._v("#")]),this._v(" Css")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"javascript"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[this._v("#")]),this._v(" Javascript")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[this._v("#")]),this._v(" Vue")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"_1-vue3为什么要用proxy替代object-defineproperty？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue3为什么要用proxy替代object-defineproperty？"}},[this._v("#")]),this._v(" 1.vue3为什么要用Proxy替代Object.defineProperty？")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("Object.defineProperty为什么可以实现响应式？")]),this._v(" "),t("li",[this._v("Object.defineProperty的劣势？")]),this._v(" "),t("li",[this._v("Proxy为什么可以实现响应式？")]),this._v(" "),t("li",[this._v("对比Object.defineProperty，Proxy的优势在哪？")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("Vue2的响应式:")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('let obj={}\nObject.defineProperty(obj,"name",{\n    value:1,//给属性赋值\n    writable:false,//是否可以赋值\n    enumerable:false,//是否可以枚举，是否可以遍历\n    configurable:false//是否可以删除\n})\nobj.name="123"\n// for(let key in obj){\n//     console.log(key);\n// }\ndelete obj.name\nconsole.log(obj.name);\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('let obj = {};\nlet value = "123";\nObject.defineProperty(obj, "name", {\n  get: function () {\n    //只要获取name属性，自动调用get方法\n    return value;\n  },\n  set: function (newValue) {\n    //只要设置name属性，自动调用set方法\n    console.log("设置name");\n    value=newValue\n  },\n});\n// value="11111"\nobj.name = "1111";\nconsole.log(obj.name);\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('// 监听数据\nlet obj = {\n  name: "张三",\n  age: 18,\n  job: {\n    code: "前端",\n    a: {},\n  },\n};\n// 封装监听数据变化的函数\nfunction dProperty(obj, key, value) {\n  // 如果存在嵌套对象的情况，通过递归解决\n  observer(value);\n  Object.defineProperty(obj, key, {\n    get: function () {\n      console.log("获取", key, "成功");\n      return value;\n    },\n    set: function (newValue) {\n      if (newValue === value) return;\n      //   如果给key赋值为一个对象的时候，需要通过递归处理\n      observer(newValue);\n      console.log("设置", key, "属性成功");\n      value = newValue;\n      //   对应页面渲染\n    },\n  });\n}\nfunction observer(obj) {\n  if (typeof obj !== "object" || obj == null) {\n    return;\n  }\n  //   给对象每一个属性设置响应式\n  for (let key in obj) {\n    dProperty(obj, key, obj[key]);\n  }\n}\nobserver(obj);\n// obj.name = "李四";\n// console.log(obj.age);\n// obj.job.code = "php";\n// console.log(obj.job.code);\n// obj.name = {\n//   sname: "小张",\n// };\n// obj.name.sname = "小李";\n// console.log(obj.name.sname);\nobj.gender="男"\nconsole.log(obj.gender);\n// 删除和添加都不能劫持 set delete\nlet arr=[1,2,3,4]\narr.forEach((item,index)=>{\n    dProperty(arr,index,item)\n})\nconsole.log(arr[0]);\narr.push(111)  //重写数组的api\nconsole.log(arr);\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("弊端：")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("1、对对象的添加和删除操作，无法劫持到")]),this._v(" "),t("li",[this._v("2、对数组的api无法劫持到")]),this._v(" "),t("li",[this._v("3、存在深层嵌套关系，性能问题")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Vue3基于ES6新增的"),t("strong",[this._v("Proxy对象")]),this._v("实现数据代理以及通过"),t("strong",[this._v("Reflect")]),this._v("对源数据进行操作，它解决了Vue2中无法追踪数据新增或删除属性的问题。另外，Proxy可以直接监听数组，无需像Vue2响应式那样需要重写数组方法进行拦截")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("Proxy（代理）")]),this._v(": 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("Reflect（反射）")]),this._v(": 对源对象的属性进行操作")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('function isObject(obj) {\n  if (typeof obj !== "object" || obj == null) {\n    return false;\n  } else {\n    return true;\n  }\n}\n// reactive ref\nfunction reactive(obj) {\n  if (typeof obj !== "object" || obj == null) {\n    return obj;\n  }\n  //   proxy是对整个对象代理，不需要通过遍历\n  let proxy = new Proxy(obj, {\n    get(target, key) {//懒加载\n      console.log("get", key);\n      return isObject(Reflect.get(target, key)) ? reactive(Reflect.get(target, key)) : Reflect.get(target, key); //===target[key]\n    },\n    set(target, key, value) {\n      console.log("set", key, value);\n      return Reflect.set(target, key, value);\n    },\n    deleteProperty(target, key) {\n      console.log("delete", key);\n      return Reflect.deleteProperty(target, key);\n    },\n  });\n  return proxy;\n}\nlet obj = reactive({ name: "张三", job: { code: "前端" } });\n// obj.name="小张"\n// console.log(obj.name);\n// obj.job.code = "php";\n// console.log(obj.job.code);\nlet arr=reactive([1,2,3,4])\narr.push(111)\nconsole.log(arr);\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('// Object.defineProperty 是对象的方法监听不到数组的变更的 Vue2.x的做法是重写数组的7个方法\n// 将原型上所有的方法都拿过来\nconst arrayMethods = Array.prototype;\n// 先克隆一份Array的原型出来\n// Object.create() 是把现有对象的属性，挂到新建对象的原型上，新建对象为空对象\nconst arrayProto = Object.create(arrayMethods);\n// 将能改变数组的七个方法，就是需要重写的方法\nconst methodsToPatch = [\n  "push",\n  "pop",\n  "shift",\n  "unshift",\n  "splice",\n  "sort",\n  "reverse",\n];\nmethodsToPatch.forEach((method) => {\n  // 给新建的对象上添加这七个方法，后面在将这个对象挂载到要实现监听的对象上，在observer中\n  arrayProto[method] = function () {\n    // 执行原始操作，这样在函数中不管是调用了原始数组的方法，还可以做一些其他的相关的操作\n    arrayMethods[method].apply(this, arguments);\n    // 监听属性\n    console.log("监听赋值成功", method);\n  };\n});\n\nfunction defineProperty(obj, key, val) {\n  observer(val);\n  Object.defineProperty(obj, key, {\n    get() {\n      // 读取方法\n      console.log("读取", key, "成功");\n      return val;\n    },\n    set(newval) {\n      // 赋值监听方法\n      if (newval === val) return;\n      // 遍历监听数据的每一项\n      observer(newval);\n      console.log("监听赋值成功", newval);\n      val = newval;\n      // 可以执行渲染操作\n    },\n  });\n}\n\nfunction observer(obj) {\n  if (typeof obj !== "object" || obj == null) {\n    return;\n  }\n  if (Array.isArray(obj)) {\n    // 如果是数组, 重写原型\n    obj.__proto__ = arrayProto;\n    // 传入的数据可能是多维度的,也需要执行响应式\n    for (let i = 0; i < obj.length; i++) {\n      observer(obj[i]);\n    }\n  } else {\n    for (const key in obj) {\n      // 给对象中的每一个方法都设置响应式\n      defineProperty(obj, key, obj[key]);\n    }\n  }\n}\nlet arr = [1, 2, 3, 4];\nobserver(obj)\nobserver(arr);\narr.push(111);\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的")]),this._v(" "),t("li",[this._v("Proxy可以直接监听数组的变化（push、shift、splice）")]),this._v(" "),t("li",[this._v("Proxy有多达13种拦截方法,不限于appl、ownKeys、deleteProperty、has等等，这是Object.defineProperty不具备的。\n正因defineProperty自身的缺陷，导致Vue2在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外set、delete方法）\n但是也有不好的问题，Proxy 不兼容IE。")])])}],!1,null,null,null);t.default=o.exports}}]);