<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>黑马课程笔记 | 小栗子的知识库</title>
    <meta name="description" content="我的个人网站">
    
    
    <link rel="preload" href="/assets/css/0.styles.6aaa91c1.css" as="style"><link rel="preload" href="/assets/js/app.74c4e6cc.js" as="script"><link rel="preload" href="/assets/js/3.a5e28c40.js" as="script"><link rel="prefetch" href="/assets/js/10.2803122b.js"><link rel="prefetch" href="/assets/js/11.6fe180f8.js"><link rel="prefetch" href="/assets/js/12.045af6f4.js"><link rel="prefetch" href="/assets/js/13.829ba624.js"><link rel="prefetch" href="/assets/js/14.26e60d35.js"><link rel="prefetch" href="/assets/js/15.6ddb0ca7.js"><link rel="prefetch" href="/assets/js/16.b956b9f4.js"><link rel="prefetch" href="/assets/js/17.0966bb36.js"><link rel="prefetch" href="/assets/js/2.f3129223.js"><link rel="prefetch" href="/assets/js/4.9d104acd.js"><link rel="prefetch" href="/assets/js/5.3b5235b7.js"><link rel="prefetch" href="/assets/js/6.32ca3a9e.js"><link rel="prefetch" href="/assets/js/7.678692eb.js"><link rel="prefetch" href="/assets/js/8.c6e0c3ad.js"><link rel="prefetch" href="/assets/js/9.de46f015.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6aaa91c1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/logo.png" alt="小栗子的知识库" class="logo"> <span class="site-name can-hide">小栗子的知识库</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端学习</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Frontend/知识点巩固.html" class="nav-link">知识点巩固</a></li><li class="dropdown-item"><!----> <a href="/Frontend/金渡课程.html" class="nav-link">金渡课程</a></li><li class="dropdown-item"><!----> <a href="/Frontend/黑马课程.html" class="nav-link">黑马课程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Node.js</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Node/黑马课程.html" class="nav-link">黑马课程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端外部资源</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/FrontStudy/千古壹号.html" class="nav-link">千古壹号</a></li><li class="dropdown-item"><!----> <a href="/FrontStudy/poetry.html" class="nav-link">poetry</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">代码管理工具</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Frontutils/Git.html" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/Frontutils/SVN.html" class="nav-link">SVN</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Other learning</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/OtherLearning/python.html" class="nav-link">python</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/git1582364788" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端学习</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Frontend/知识点巩固.html" class="nav-link">知识点巩固</a></li><li class="dropdown-item"><!----> <a href="/Frontend/金渡课程.html" class="nav-link">金渡课程</a></li><li class="dropdown-item"><!----> <a href="/Frontend/黑马课程.html" class="nav-link">黑马课程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Node.js</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Node/黑马课程.html" class="nav-link">黑马课程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端外部资源</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/FrontStudy/千古壹号.html" class="nav-link">千古壹号</a></li><li class="dropdown-item"><!----> <a href="/FrontStudy/poetry.html" class="nav-link">poetry</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">代码管理工具</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Frontutils/Git.html" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/Frontutils/SVN.html" class="nav-link">SVN</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Other learning</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/OtherLearning/python.html" class="nav-link">python</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/git1582364788" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Node/" aria-current="page" class="sidebar-link">Node</a></li><li><a href="/Node/黑马课程.html" class="active sidebar-link">黑马课程笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_1-初识node-js" class="sidebar-link">1.初识Node.js</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_1-1回顾与思考" class="sidebar-link">1.1回顾与思考</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_1-2node-js简介" class="sidebar-link">1.2Node.js简介</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_1-3node-js环境的安装" class="sidebar-link">1.3Node.js环境的安装</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_1-4在node-js环境中执行javascript代码" class="sidebar-link">1.4在Node.js环境中执行JavaScript代码</a></li></ul></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_2-fs文件系统模块" class="sidebar-link">2.fs文件系统模块</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_2-1-什么是fs文件系统模块" class="sidebar-link">2.1 什么是fs文件系统模块</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_2-2读取指定文件中的内容" class="sidebar-link">2.2读取指定文件中的内容</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_2-3向指定的文件中写入内容" class="sidebar-link">2.3向指定的文件中写入内容</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_2-5练习-考试成绩整理" class="sidebar-link">2.5练习 - 考试成绩整理</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_2-6-fs模块-路径动态pingji拼接的问题" class="sidebar-link">2.6 fs模块-路径动态pingji拼接的问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_3-path路径模块" class="sidebar-link">3.path路径模块</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_3-1什么是-path-路径模块" class="sidebar-link">3.1什么是 path 路径模块</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_3-2路径拼接" class="sidebar-link">3.2路径拼接</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_3-3获取路径中的文件名" class="sidebar-link">3.3获取路径中的文件名</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_3-4获取路径中的文件扩展名" class="sidebar-link">3.4获取路径中的文件扩展名</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_3-5综合案例：时钟案例" class="sidebar-link">3.5综合案例：时钟案例</a></li></ul></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_4-http模块" class="sidebar-link">4.http模块</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_4-1什么是http模块" class="sidebar-link">4.1什么是http模块</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_4-2进一步理解http模块的作用" class="sidebar-link">4.2进一步理解http模块的作用</a></li></ul></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_5-模块化" class="sidebar-link">5.模块化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_5-3-npm与包" class="sidebar-link">5.3 npm与包</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_5-4-模块的加载机制" class="sidebar-link">5.4 模块的加载机制</a></li></ul></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_6-express" class="sidebar-link">6.Express</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_6-1初始express" class="sidebar-link">6.1初始Express</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_6-2-express-路由" class="sidebar-link">6.2 Express 路由</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_6-3-express-中间件" class="sidebar-link">6.3 Express 中间件</a></li><li class="sidebar-sub-header"><a href="/Node/黑马课程.html#_6-4-使用-express-写接口" class="sidebar-link">6.4 使用 Express 写接口</a></li></ul></li></ul></li></ul> </div> <div class="page"> <div class="content"><h1 id="黑马课程笔记"><a href="#黑马课程笔记" class="header-anchor">#</a> 黑马课程笔记</h1> <div class="language- extra-class"><pre class="language-text"><code>配套资源和代码在&quot;KnowledgeBase&quot;仓库的 “00-Nodejs-Vue2-Vue3（黑马课程）” 文件夹中
</code></pre></div><h2 id="_1-初识node-js"><a href="#_1-初识node-js" class="header-anchor">#</a> 1.初识Node.js</h2> <h3 id="_1-1回顾与思考"><a href="#_1-1回顾与思考" class="header-anchor">#</a> 1.1回顾与思考</h3> <h4 id="_1-浏览器中javascript的组成部分"><a href="#_1-浏览器中javascript的组成部分" class="header-anchor">#</a> 1.浏览器中javascript的组成部分</h4> <p>js核心语法：变量 ，数据类型，循环，分支，判断，函数，作用域，this etc...</p> <p>WebAPI:DOM操作，BOM操作，基于XMLHttpRequest的Ajax操作 etc...</p> <h4 id="_2-思考：为什么javascript可以在浏览器中比执行？"><a href="#_2-思考：为什么javascript可以在浏览器中比执行？" class="header-anchor">#</a> 2.思考：为什么JavaScript可以在浏览器中比执行？</h4> <p>答：浏览器中有javascript解析引擎，专门负责解析和执行javascript代码</p> <div class="language- extra-class"><pre class="language-text"><code>Chrome浏览器 =&gt; V8
Firefox浏览器 =&gt; OdinMonkey(奥丁猴)
Safri浏览器 =&gt; JSCore
IE浏览器 =&gt; Chakra(查克拉)
etc...
</code></pre></div><p>其中，Chrome浏览器的V8解析引擎性能最好！</p> <h4 id="_3-思考：为什么javascript可以操作dom和bom？"><a href="#_3-思考：为什么javascript可以操作dom和bom？" class="header-anchor">#</a> 3.思考：为什么JavaScript可以操作DOM和BOM？</h4> <p>答：每个浏览器都内置了DOM、BOM这样的API函数，因此，浏览器中的JavaScript才可以调用它们。</p> <h4 id="_4-浏览器中的javascript运行环境"><a href="#_4-浏览器中的javascript运行环境" class="header-anchor">#</a> 4.浏览器中的JavaScript运行环境</h4> <p><strong>运行环境</strong>是指代码正常运行所需的必要环境。</p> <p><img src="/assets/img/img1.e79712a6.png" alt></p> <h4 id="_5-思考：javascript能否做后端开发"><a href="#_5-思考：javascript能否做后端开发" class="header-anchor">#</a> 5.思考：javascript能否做后端开发</h4> <p>java python php</p> <p>使用javascript也可以做后端开发，只不过需要借助一个node.js。一门编程语言编写好之后，需要在运行环境中执行。如果把js代码跑在浏览器里边，浏览器本身就是一个运行环境，所以javascript可以跑在浏览器里做前端开发。 如果把js代码运行在node中，这里node也是一个运行环境，是一个后端的运行环境，这样通过node就可以用javascript做后端开发。</p> <h3 id="_1-2node-js简介"><a href="#_1-2node-js简介" class="header-anchor">#</a> 1.2Node.js简介</h3> <h4 id="_1-什么是node-js"><a href="#_1-什么是node-js" class="header-anchor">#</a> 1.什么是Node.js</h4> <div class="language- extra-class"><pre class="language-text"><code>Node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine.

Node.js是一个基于Chrome V8 引擎的Javascript运行环境
</code></pre></div><p>Node.js的官方网址：<a href="https://nodejs/org/zh-cn" target="_blank" rel="noopener noreferrer">https://nodejs/org/zh-cn<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>在众多的浏览器中，Chrome V8引擎解析执行js代码性能最好。</p> <h4 id="_2-node-js中的javascript运行环境"><a href="#_2-node-js中的javascript运行环境" class="header-anchor">#</a> 2.Node.js中的JavaScript运行环境</h4> <p>分为两个部分：V8引擎和内置API</p> <p>V8引擎负责解析执行js代码；内置API提供了一些能力，让我们在js中调用node为我们提供的这些内置API去做一些后端的事情。</p> <p><img src="/assets/img/img2.1189df90.png" alt></p> <p>学习node.js一个很重要的部分就是学习这些内置的API如何使用。</p> <p>注意：</p> <ul><li>浏览器是JavaScript的前端运行环境。</li> <li>Node.js是JavaScript的后端运行环境。</li> <li>Node.js中无法调用DOM和BOM等浏览器内置API。因为node里没有内置这些API函数</li></ul> <h4 id="_3-node-js可以做什么"><a href="#_3-node-js可以做什么" class="header-anchor">#</a> 3.Node.js可以做什么</h4> <p>Node.js作为一个JavaScript的运行环境，仅仅提供了基础的功能和API。然而，基于Nodejs提供的这些基础功能，很多强大的工具和框架如雨后春笋，层出不穷。所以学会了Nodejs，可以让前端程序员胜任更多的工作和岗位:</p> <p>①：基于Express框架(<a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener noreferrer">http://www.expressjs.com.cn/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>),可以快速构建Web应用</p> <p>②：基于Electron框架(<a href="https://electronjs.org/" target="_blank" rel="noopener noreferrer">https://electronjs.org/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>) ，可以构建跨平台的桌面应用</p> <p>③：基于restify框架(<a href="http://restify.com" target="_blank" rel="noopener noreferrer">http://restify.com<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>) ，可以快速构建API接口项目</p> <p>④：读写和操作数据库、创建实用的命令行工具辅助前端开发、etc...</p> <p>总之，Node.js是大前端时代的“大宝剑”，有了Node.js这个超级buff的加持，前端程序员的行业竞争力会越来越强！</p> <h4 id="_4-node-js好学吗"><a href="#_4-node-js好学吗" class="header-anchor">#</a> 4.Node.js好学吗</h4> <p>好学！</p> <p>会javascript，就能学会Node.js！！！</p> <h4 id="_5-node-js怎么学"><a href="#_5-node-js怎么学" class="header-anchor">#</a> 5.Node.js怎么学</h4> <div class="language- extra-class"><pre class="language-text"><code>浏览器中的JavaScript学习路径:
JavaScript基础语法 + 浏览器内置API (DOM + BOM) + 第三方库jQuery, art-template 等)

Node.js的学习路径:
JavaScript基础语法 + Nodejs内置API模块(fs, path, http等) + 第三方API模块(express，mysql 等)
</code></pre></div><p>重点学习Nodejs内置API和第三方API模块</p> <h3 id="_1-3node-js环境的安装"><a href="#_1-3node-js环境的安装" class="header-anchor">#</a> 1.3Node.js环境的安装</h3> <p>如果希望通过Nodejs来运行Javascript代码,则必须在计算机上安装Node.js环境才行。</p> <p>安装包可以从Node.js的官网首页直接下载，进入到Node.js的官网首页(<a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer">https://nodejs.org/en/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>) ,点击绿色的按钮，下载所需的版本后，双击直接安装即可。</p> <p><img src="/assets/img/img3.e3b4aa98.png" alt></p> <h4 id="_1-区分lts版本和current版本的不同"><a href="#_1-区分lts版本和current版本的不同" class="header-anchor">#</a> 1.区分LTS版本和Current版本的不同</h4> <p>①：LTS为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装LTS版本的Node.js。</p> <p>②：Current为新特性尝鲜版，对热衷于尝试新特性的用户来说，推荐安装Current版本的Nodejs。但是，Current 版本中可能存在隐藏的Bug或安全性漏洞，因此不推荐在企业级项目中使用Curent版本的Node.js。</p> <p>我们知道node一直在更新，当它更新了一个新特性之后就会把这些新特性放到current版本中进行测试，如果测试没有问题，才会把这些特性移植到稳定版。</p> <p>安装node的时候一般不建议更改目录，默认安装到c盘。
这里不要勾选复选框，直接点击next</p> <p><img src="/assets/img/img4.38a19d6d.png" alt></p> <h4 id="_2-查看已安装的node-js的版本号"><a href="#_2-查看已安装的node-js的版本号" class="header-anchor">#</a> 2.查看已安装的Node.js的版本号</h4> <p>打开终端，在终端输入命令node-v后，按下回车键，即可查看已安装的Node.js的版本号。</p> <div class="language- extra-class"><pre class="language-text"><code>Windows系统快速打开终端的方式:
使用快捷键(Windows微标键 + R)打开运行面板，输入cmd后直接回车，即可打开终端。
</code></pre></div><h4 id="_3-什么是终端（拓展知识点）"><a href="#_3-什么是终端（拓展知识点）" class="header-anchor">#</a> 3.什么是终端（拓展知识点）</h4> <p>终端（英文：Terminal）是专门为开发人员设计的，<strong>用于实现人机交互</strong>的一种方式。</p> <p>作为一名合格的程序员，我们有必要识记一些<strong>常用的终端命令</strong>，来辅助我们更好地操作与使用计算机。只有程序员（IT开发者）会使用终端。</p> <h3 id="_1-4在node-js环境中执行javascript代码"><a href="#_1-4在node-js环境中执行javascript代码" class="header-anchor">#</a> 1.4在Node.js环境中执行JavaScript代码</h3> <p>①：打开终端</p> <p>②: 输入 node 要执行地js文件的路径</p> <p>切换到执行文件所处的目录中：</p> <p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ8AAABhCAYAAADIpiSgAAAG/ElEQVR4nO2dDY7kKAxGa1p9sDl63Wx2SxpWLDJgGzuQ9HsS6q4KOOYnXwzpJr9er9efFwCAka/dDgDAPUE8AMAF4gEALhAPAHCBeACAC8QDAFwgHgDgAvEAABch4vF+vyPMbOPu/gPs4Nfr71+YShfQ79+/1YY+5aX8td1yXPpuNz3/T/CjJ251e/Z8X+1XgBF//h1gHwH5X5K+G6VR/gj72cnrz6dcRF2KHW9bWdr/tLYn3TOx5rFI1F38Y2fF1qesdvplyQvQ46sX8vamIKMQ+s4D8u7+f1itw6h/AVq+dztQmM3N2+O99ZPeekrEms6s/GgtZ3WdR1u+tAHrGpBO5Py3Z2s2j189Xj73ymjXEVb8H60rWNYctHW19MUd1pxI90uhax6Rob/nzlmXmZXvTdUs6wYze9IxT/tI5xrZIfKAKzhi2iJdDNrHlVH2M8t/KOWz11YQDriS8LBWE2bP7M/C7lV/rVMHq3+Z0xZrmzJtIWUkcdrSu3tlrcZ7bFrKrPocWecIW1L/WCKOq/sXnon4F6azv1acDdLe4K6xPgnRPG3RlpXytPm1/kntNvqunrZY2mDUPyPhsNRd278AhZSQ5u5h8d39J5GyE39hCgAu/pu2AABYIPIAABeIBwC4QDwAwAXiAQAuEA8AcIF4AIALxAMAXCAeAOAC8QAAF4gHALhAPADABeIBAC4QDwBwgXgAgAvEAwBcIB5wG3r7q7Lv6h6OePUCQCZWcWEPVx0hO4k9/V0hT6/fbjTtW+fRiIG3v1Z3pv9RvP++KrFOL8dmqKvvQclKV9RvpZ6Sf733rFjedRPdfrX9lXb0+m55J02GH6dsiH2KH5/0VRT187Ok6DlktE3L+0WuqN8Kkn9WHzPft9K74155J7ZGHTNb2WT0x4nv1BEXTE8XkNWBmykgUYNbej/t6EJ+alhd2qO9eOrP1ptJ9kWY0Rcn9rHpacuokzSdctpdv2WlfsyL1+i1bx2Nlc/tT2u7e8bh6WN3B5c/bSmdIHV43TnSotWTmQlTYWUhsCZa6HoXvva4xn5r7ySxno3PXh9K30f091WEvQjZUqbNO/q86t8V9Zv5q7WrPYfleFT7tT+19rXnt/o/Stb279Uton0tY91zrl0pNPIYRRU1mrvIiYo7q9+To6NSb8vagvW41L71ukadT4pMrWOm2NSW045vqVx7zpHd06KqHpdPW+7SMBZ6A95DVtus+jQKpSVRqfPMjmvO3ZvmWkVk15SgFqqn3GTCxcPa2XdDc/fx3qEyyfZldhFrL3Kp7Sy+j6IXqy2t/Rma/LWonDRuRohPW0YXv1c1Rw0oqfHoPKvKnVG/uxFZz5mtqHPV/WMZTyXfVRdl5tg9ie/enDISq/K2PkjHykCa2c2unzSYNQN8VL6Xp/69d2eVjq9MG7TM7HvPL/WbJ6rLFI7Z+GyjitHY9Y6BXaSsxL4PWhWmfvdL78nTmvbYSn94bGT0/93GFP9Vm8wsTN199zjdv5kPEetLu9eoTookLIT8Vy0A/DzEBVMAgBmIBwC4QDwAwAXiAQAuEA8AcIF4AIALxAMAXCAeAOAC8QAAF4gHALhAPADABeIBAC4QDwBwgXgAgAvEAwBcIB4Porexz5P2zYRzYCcxMIvL3Xa8ghxCdhLbuYXbT0C7kXK7AfMIb39JvtD/P5T34qv6StKU89iW/JPsaHzP2rS23UB3pR29vveOX+XHKZv39sbGbr+emL7qd1q028SfgOSf1cey1X2mf9rvM7BGHTNb2WT0x8jmaWP6KYgLppmNHTW424uziIrE6NjdKe3RXjz1Z8vFesWFltEXsz5GQOIxPW1ZUXfmxWv02reOxsrn9qfnBUmeRdTTL847+HgnbvO0ZSZMhZWFwJpooetd+NrjGvutvZPEenbR9vpQ+n6lv3e/o+VphC0yjcrUx6y2tWUjFxUtPkoLphb72vNb/R8la/v36hbRvrP2Wm2LlXykfgqNPGaq/uSQsdTbsrZgPS61b72uUeeLeJzaW1/q4b2rayKw2u5q5EDkEcMl05begPeQ1emrPo1CaUlU6jyz45pzS/ml72cXTsQU0EMtVJk3GYQjlvBn4ythp8aeN99qqKuxne2r9xyzaYJ2OuPJszptaf3MbjeSLolPW0Z3sidPPWoi6zmzFXWuun9Gd9hepHTVHXlU36zxRcQRz3dvzhyFNJg1A3xUvpen/r03TZKOr0wbtMzse88v9dvqukM0klgVoSvrM+20pVcHzxhAOPJICWkIEXPTKOyX8kVMQzOmmt46k/an7X/nMQtTd98xTvdv5oP3CUi0jRWkaBH2E/JftQDw82AzIABwgXgAgAvEAwBcIB4A4ALxAAAXiAcAuEA8AMAF4gEALhAPAHDxD6XmLGQjbF/TAAAAAElFTkSuQmCC" alt></p> <p>优化在nodejs环境中执行js代码的方式，在打开终端的那一刻就直接定位到文件所处的目录中。</p> <div class="language- extra-class"><pre class="language-text"><code>打开文件所处的目录，按住shiift健单击鼠标的右键，会出现一个PowerShell选项，点击后打开PowerShell终端窗口，自动定位到当前所属的目录。

</code></pre></div><p><img src="/assets/img/img6.ff151b10.png" alt></p> <p><img src="/assets/img/img7.ad0952db.png" alt></p> <p>这两个有什么区别？cmd出现的早一些，它是旧版的windows里边的终端，后来windows做了一次升级改造，改造成了PowerShell终端。用哪个都行，只不过cmd功能基础一些，PowerShell功能强大一些。今后建议使用PowerShell方式运行js文件。</p> <h4 id="_1-终端中的快捷键"><a href="#_1-终端中的快捷键" class="header-anchor">#</a> 1.终端中的快捷键</h4> <p>在Windows的powershell或cmd终端中,我们可以通过如下快捷键，来提高终端的操作效率:</p> <p>①使用1键，可以快速定位到上一次执行的命令</p> <p>②使用tab键,能够快速补全路径</p> <p>③使用esc键，能够快速清空当前已输入的命令</p> <p>④输入cls命令,可以清空终端</p> <h2 id="_2-fs文件系统模块"><a href="#_2-fs文件系统模块" class="header-anchor">#</a> 2.fs文件系统模块</h2> <h3 id="_2-1-什么是fs文件系统模块"><a href="#_2-1-什么是fs文件系统模块" class="header-anchor">#</a> 2.1 什么是fs文件系统模块</h3> <p>fs模块是Node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性， 用来满足用户对文件的操作需求。</p> <p>例如：</p> <ul><li>fs.readFile()方法，用来读取指定文件中的内容</li> <li>fs.writeFile()方法，用来向指定的文件中写入内容</li></ul> <p>如果要在JavaScript代码中，使用fs模块来操作文件,则需要使用如下的方式先导入它:</p> <div class="language- extra-class"><pre class="language-text"><code>const fs = require('fs')
</code></pre></div><p>fs模块到底是从何而来？只要安装了nodejs，在安装它的时候会自动把这些模块安装到电脑本地。node会自动帮我们查找。</p> <h3 id="_2-2读取指定文件中的内容"><a href="#_2-2读取指定文件中的内容" class="header-anchor">#</a> 2.2读取指定文件中的内容</h3> <h4 id="_1-fs-readfile-的语法格式"><a href="#_1-fs-readfile-的语法格式" class="header-anchor">#</a> 1. fs.readFile()的语法格式</h4> <p>使用fs.readFile()方法，可以读取指定文件中的内容，语法格式如下：</p> <div class="language- extra-class"><pre class="language-text"><code>fs.readFile(path[, options], callback)
</code></pre></div><p>参数解读:</p> <ul><li>参数1:必选参数，字符串，表示文件的路径。</li> <li>参数2:可选参数，表示以什么编码格式来读取文件。</li> <li>参数3:必选参数，文件读取完成后，通过回调函数拿到读取的结果。</li></ul> <h4 id="_2-fs-readfile-的示范代码"><a href="#_2-fs-readfile-的示范代码" class="header-anchor">#</a> 2. fs.readFile()的示范代码</h4> <p>以utf8的编码格式，读取指定文件的内容，并打印err和dataStr的值:</p> <div class="language- extra-class"><pre class="language-text"><code>const fs = require('fs')
fs.readFile('./files/11.txt', 'utf8', function(err, dataStr) { 
    // 如果读取成功，err的值为null
    // 如果读取失败，err的值为错误对象，dataStr的值为undefined
   console. log(err) 
   // 打印成功的结果
   console. log(dataStr)
})
</code></pre></div><h4 id="_3-判断文件是否读取成功"><a href="#_3-判断文件是否读取成功" class="header-anchor">#</a> 3.判断文件是否读取成功</h4> <p>可以判断err对象是否为null，从而知晓文件读取的结果：</p> <div class="language- extra-class"><pre class="language-text"><code>const fs = require('fs')

fs.readFile('./files/1.txt','utf8',function(err, dataStr){
    if(err){ // err为ture，也就是err不为null，读取文件失败
        return console.log('读取文件失败' + err.message)
    }
    console.log('读取文件成功！' + dataStr)
})
</code></pre></div><h3 id="_2-3向指定的文件中写入内容"><a href="#_2-3向指定的文件中写入内容" class="header-anchor">#</a> 2.3向指定的文件中写入内容</h3> <h4 id="_1-fs-writefile-file-data-options-callback"><a href="#_1-fs-writefile-file-data-options-callback" class="header-anchor">#</a> 1. fs.writeFile(file, data[. options]. callback)</h4> <p>使用fs.writeFile()方法，可以向指定的文件中写入内容，语法格式如下:</p> <div class="language- extra-class"><pre class="language-text"><code>fs.writeFile(file, data[, options], callback)
</code></pre></div><p>参数解读:</p> <ul><li>参数1:必选参数,需要指定一个文件路径的字符串，表示文件的存放路径。</li> <li>参数2:必选参数，表示要写入的内容。</li> <li>参数3:可选参数，表示以什么格式写入文件内容，默认值是utf8.</li> <li>参数4:必选参数，文件写入完成后的回调函数。</li></ul> <h4 id="_2-fs-wirtefile-的示例代码"><a href="#_2-fs-wirtefile-的示例代码" class="header-anchor">#</a> 2. fs.wirteFile()的示例代码</h4> <div class="language- extra-class"><pre class="language-text"><code>// 1.导入fs文件系统模块
const fs = require('fs')

// 2.调用fs.writeFile方法写入文件内容
// 参数1：表示文件的存放路径
// 参数2：表示写入的内容
// 参数3：回调函数，成功与失败都会调用该函数
// 参数4：编码（可选参数），不写的话默认'utf8'
fs.writeFile('files/2.txt','data',function(err){
// fs.writeFile('F:/files/2.txt','data',function(err){
    console.log(err);
    // 2.1如果打印成功，err为null
    // 2.2如果打印失败，err为一个错误对象
})
</code></pre></div><h4 id="_3-判断文件是否写入成功"><a href="#_3-判断文件是否写入成功" class="header-anchor">#</a> 3.判断文件是否写入成功</h4> <p>可以判断err对象是否为null, 从而知晓文件写入的结果:</p> <div class="language- extra-class"><pre class="language-text"><code>const fs = require('fs')
fs.writeFile('files/2.txt','data',function(err){
    if(err){
        return console.log('文件写入失败！' + err.message)
    }
    console.log('文件写入成功')
})
</code></pre></div><h3 id="_2-5练习-考试成绩整理"><a href="#_2-5练习-考试成绩整理" class="header-anchor">#</a> 2.5练习 - 考试成绩整理</h3> <p>使用fs文件系统模块，将素材目录下成绩.txt文件中的考试数据，整理到成绩-ok.txt文件中。整理前，成绩.txt文件中的数据格式如下:</p> <div class="language- extra-class"><pre class="language-text"><code>小红=99 小白=108 小黄=78 小黑=66 小绿=88
</code></pre></div><p>整理完成之后，希望得到的成绩-ok.txt文件中的数据格式如下:</p> <div class="language- extra-class"><pre class="language-text"><code>小红：99
小白：:100
小黄：70
小黑：66
小绿：88
</code></pre></div><p><strong>核心实现步骤</strong></p> <p>①导入需要的fs文件系统模块</p> <p>②使用 fs.readFile() 方法，读取素材目录下的 成绩.txt 文件</p> <p>③判断文件是否读取失败</p> <p>④文件读取成功后，处理成绩数据</p> <p>⑤将处理完成的成绩数据，调用 fs.writeFile() 方法，写入到新文件 成绩-ok.txt 中</p> <div class="language- extra-class"><pre class="language-text"><code>代码：
// 1. 导入 fs 模块
const fs = require('fs')

// 2. 调用 fs.readFile() 读取文件的内容
fs.readFile('../素材/成绩.txt', 'utf8', function(err, dataStr) {
  // 3. 判断是否读取成功
  if (err) {
    return console.log('读取文件失败！' + err.message)
  }
  // console.log('读取文件成功！' + dataStr)

  // 4.1 先把成绩的数据，按照空格进行分割
  const arrOld = dataStr.split(' ')
  // 4.2 循环分割后的数组，对每一项数据，进行字符串的替换操作
  const arrNew = []
  arrOld.forEach(item =&gt; {
    arrNew.push(item.replace('=', '：'))
  })
  // 4.3 把新数组中的每一项，进行合并，得到一个新的字符串
  const newStr = arrNew.join('\r\n')

  // 5. 调用 fs.writeFile() 方法，把处理完毕的成绩，写入到新文件中
  fs.writeFile('./files/成绩-ok.txt', newStr, function(err) {
    if (err) {
      return console.log('写入文件失败！' + err.message)
    }
    console.log('成绩写入成功！')
  })
})
</code></pre></div><h3 id="_2-6-fs模块-路径动态pingji拼接的问题"><a href="#_2-6-fs模块-路径动态pingji拼接的问题" class="header-anchor">#</a> 2.6 fs模块-路径动态pingji拼接的问题</h3> <p>在使用fs模块操作文件时，如果提供的操作路径是以./或../开头的相对路径时,很容易出现路径动态拼接错误的问题。</p> <p>原因:代码在运行的时候，会以执行node命令时所处的目录，动态拼接出被操作文件的完整路径。
<img src="/assets/img/img8.634fd076.png" alt></p> <p>解决方案:在使用fs模块操作文件时，直接提供完整的路径（从盘符开始），不要提供./或../开头的相对路径，从而防止路径动态拼接的问题。</p> <div class="language- extra-class"><pre class="language-text"><code>const fs = require('fs')

// 出现路径拼接错误的问题，是因为提供了 ./ 或 ../ 开头的相对路径
// 如果要解决这个问题，可以直接提供一个完整的文件存放路径就行
/* fs.readFile('./files/1.txt', 'utf8', function(err, dataStr) {
  if (err) {
    return console.log('读取文件失败！' + err.message)
  }
  console.log('读取文件成功！' + dataStr)
}) */

// 移植性非常差、不利于维护
/* fs.readFile('C:\\Users\\escook\\Desktop\\Node.js基础\\day1\\code\\files\\1.txt', 'utf8', function(err, dataStr) {
  if (err) {
    return console.log('读取文件失败！' + err.message)
  }
  console.log('读取文件成功！' + dataStr)
}) */

// __dirname 表示当前文件所处的目录
// console.log(__dirname)

fs.readFile(__dirname + '/files/1.txt', 'utf8', function(err, dataStr) {
  if (err) {
    return console.log('读取文件失败！' + err.message)
  }
  console.log('读取文件成功！' + dataStr)
})
</code></pre></div><h2 id="_3-path路径模块"><a href="#_3-path路径模块" class="header-anchor">#</a> 3.path路径模块</h2> <h3 id="_3-1什么是-path-路径模块"><a href="#_3-1什么是-path-路径模块" class="header-anchor">#</a> 3.1什么是 path 路径模块</h3> <p>path模块是Node.js官方提供的、用来处理路径的模块。它提供了一系列的方法和属性， 用来满足用户对路径的处理需求。</p> <p>例如：</p> <ul><li>path.join() 方法，用来将多个路径片段拼接成一个完整的路径字符串</li> <li>path.basename() 方法，用来从路径字符串中，将文件名解析出来</li></ul> <p>如果要在JavaScript代码中,使用path模块来处理路径，则需要使用如下的方式先导入它:</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path')
</code></pre></div><h3 id="_3-2路径拼接"><a href="#_3-2路径拼接" class="header-anchor">#</a> 3.2路径拼接</h3> <p>使用path.join()方法，可以把多个路径片段拼接为完整的路径字符串,语法格式如下:</p> <div class="language- extra-class"><pre class="language-text"><code>path.join([...paths])
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>参数解读：
- ...paths &lt;string&gt; 路径片段的序列
- 返回值: &lt;string&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>const pathStr = path.join('/a', '/b/C', '../'. './d&quot;. 'e')
console.log(pathSstr) // 输出 \a\b\d\e

const pathStr2 = path.join(__dirname, ./files/1. txt')
console.log(pathStr2) // 输出当前文件所处 目录\filesl1.txt
</code></pre></div><p>注意:今后凡是涉及到路径拼接的操作,都要使用path.join()方法进行处理。不要直接使用+进行字符串的拼接。</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path')
const fs = require('fs')

// 注意：  ../ 会抵消前面的路径
// const pathStr = path.join('/a', '/b/c', '../../', './d', 'e')
// console.log(pathStr)  // \a\b\d\e

// fs.readFile(__dirname + '/files/1.txt')

fs.readFile(path.join(__dirname, './files/1.txt'), 'utf8', function(err, dataStr) {
  if (err) {
    return console.log(err.message)
  }
  console.log(dataStr)
})
</code></pre></div><h3 id="_3-3获取路径中的文件名"><a href="#_3-3获取路径中的文件名" class="header-anchor">#</a> 3.3获取路径中的文件名</h3> <p>使用path.basename()方法，可以获取路径中的最后一部分,经常通过这个方法获取路径中的文件名,语法格式如下:</p> <div class="language- extra-class"><pre class="language-text"><code>path.basename(path[, ext])
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>参数解读:
- path &lt;string&gt;必选参数,
- path &lt;string&gt;必选参数,表示个路径的字符串
- 返回: &lt;string&gt;表示路径中的最后一部分
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>const path = require('path')

// 定义文件的存放路径
const fpath = '/a/b/c/index.html'

// const fullName = path.basename(fpath)
// console.log(fullName)

const nameWithoutExt = path.basename(fpath, '.html')
console.log(nameWithoutExt)
</code></pre></div><h3 id="_3-4获取路径中的文件扩展名"><a href="#_3-4获取路径中的文件扩展名" class="header-anchor">#</a> 3.4获取路径中的文件扩展名</h3> <p>使用path.extname()方法，可以获取路径中的扩展名部分,语法格式如下:</p> <div class="language- extra-class"><pre class="language-text"><code>path.extname(path)
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>参数解读：
- path &lt;string&gt;必选参数, 表示个路径的字符串
- 返回: &lt;string&gt;返回得到的扩展名字符串
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>const path = require('path')

// 这是文件的存放路径
const fpath = '/a/b/c/index.html'

const fext = path.extname(fpath)
console.log(fext)

</code></pre></div><h3 id="_3-5综合案例：时钟案例"><a href="#_3-5综合案例：时钟案例" class="header-anchor">#</a> 3.5综合案例：时钟案例</h3> <p>案例的实现步骤</p> <div class="language- extra-class"><pre class="language-text"><code>1. 创建两个正则表达式，分别用来匹配&lt;style&gt; 和&lt;script&gt; 标签
2. 使用fs模块，读取需要被处理的HTML文件
3. 自定义resolveCSS方法，来写入index.css样式文件
4. 自定义resolveJS方法,来写入indexjs脚本文件
5. 自定义resolveHTML方法，来写入index.html 文件
</code></pre></div><h2 id="_4-http模块"><a href="#_4-http模块" class="header-anchor">#</a> 4.http模块</h2> <h3 id="_4-1什么是http模块"><a href="#_4-1什么是http模块" class="header-anchor">#</a> 4.1什么是http模块</h3> <p>回顾：什么是客户端、什么是服务器？</p> <div class="language- extra-class"><pre class="language-text"><code>在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。
</code></pre></div><p>http模块是Node.js官方提供的、用来创建web服务器的模块。通过http模块提供的http.createServer()方法，就能方便地把一台普通地电脑，变成一台web服务器，从而对外提供Web资源服务。自己可以手写一台web服务器。</p> <p>如果要希望使用http模块创建啊web服务器，则需要先导入它：</p> <div class="language- extra-class"><pre class="language-text"><code>const http = require('http')
</code></pre></div><h3 id="_4-2进一步理解http模块的作用"><a href="#_4-2进一步理解http模块的作用" class="header-anchor">#</a> 4.2进一步理解http模块的作用</h3> <h2 id="_5-模块化"><a href="#_5-模块化" class="header-anchor">#</a> 5.模块化</h2> <h3 id="_5-3-npm与包"><a href="#_5-3-npm与包" class="header-anchor">#</a> 5.3 npm与包</h3> <h4 id="_4-解决下包速度慢的问题"><a href="#_4-解决下包速度慢的问题" class="header-anchor">#</a> 4. 解决下包速度慢的问题</h4> <ol><li>为什么下包速度慢</li></ol> <p>在使用 npm 下包的时候，默认从国外的 <a href="https://registry.npmjs.org/" target="_blank" rel="noopener noreferrer">https://registry.npmjs.org/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 服务器进行下载，此时，网络数据的传输需要经过漫长的海底光缆，因此下包速度会很慢。</p> <p>扩展阅读 - 海底光缆：</p> <ul><li><p><a href="https://baike.baidu.com/item/%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/4107830" target="_blank" rel="noopener noreferrer">https://baike.baidu.com/item/%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/4107830<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p><a href="https://baike.baidu.com/item/%E4%B8%AD%E7%BE%8E%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/10520363" target="_blank" rel="noopener noreferrer">https://baike.baidu.com/item/%E4%B8%AD%E7%BE%8E%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/10520363<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p><a href="https://baike.baidu.com/item/APG/23647721?fr=aladdin" target="_blank" rel="noopener noreferrer">https://baike.baidu.com/item/APG/23647721?fr=aladdin<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul> <ol start="2"><li><p>淘宝 NPM 镜像服务器</p></li> <li><p>切换 npm 的下包镜像源</p></li></ol> <p>下包的镜像源，指的就是下包的服务器地址。</p> <ol start="4"><li>nrm</li></ol> <p>为了更方便的切换下包的镜像源，我们可以安装 nrm 这个小工具，利用 nrm 提供的终端命令，可以快速查看和切换下
包的镜像源。</p> <h4 id="_5-包的分类"><a href="#_5-包的分类" class="header-anchor">#</a> 5.包的分类</h4> <p>使用 npm 包管理工具下载的包，共分为两大类，分别是：</p> <ul><li><p>项目包</p></li> <li><p>全局包</p></li></ul> <ol><li>项目包
那些被安装到项目的 node_modules 目录中的包，都是项目包。</li></ol> <p>项目包又分为两类，分别是：</p> <ul><li><p>开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到）</p></li> <li><p>核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到</p></li></ul> <ol start="2"><li>全局包
在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包。
全局包会被安装到 C:\Users\用户目录\AppData\Roaming\npm\node_modules 目录下。</li></ol> <p>注意：</p> <p>① 只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。</p> <p>② 判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可</p> <h4 id="_6-规范的包结构"><a href="#_6-规范的包结构" class="header-anchor">#</a> 6.规范的包结构</h4> <p>在清楚了包的概念、以及如何下载和使用包之后，接下来，我们深入了解一下包的内部结构。</p> <p>一个规范的包，它的组成结构，必须符合以下 3 点要求：</p> <p>① 包必须以单独的目录而存在</p> <p>② 包的顶级目录下要必须包含 package.json 这个包管理配置文件</p> <p>③ package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口。</p> <p>注意：以上 3 点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址：</p> <p><a href="https://yarnpkg.com/zh-Hans/docs/package-json" target="_blank" rel="noopener noreferrer">https://yarnpkg.com/zh-Hans/docs/package-json<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h4 id="_7-开发属于自己的包"><a href="#_7-开发属于自己的包" class="header-anchor">#</a> 7.开发属于自己的包</h4> <ol><li>需要实现的功能</li></ol> <p>① 格式化日期</p> <p>② 转义 HTML 中的特殊字符</p> <p>③ 还原 HTML 中的特殊字符</p> <ol start="2"><li>初始化包的基本结构
① 新建 itheima-tools 文件夹，作为包的根目录</li></ol> <p>开发自己的包时区npmjs网站搜一下看有没有被占用。</p> <p>② 在 itheima-tools 文件夹中，新建如下三个文件：</p> <ul><li>package.json （包管理配置文件）</li> <li>index.js （包的入口文件）</li> <li>README.md （包的说明文档）</li></ul> <ol start="3"><li>初始化 package.json</li></ol> <p>关于更多 license 许可协议相关的内容，可参考 <a href="https://www.jianshu.com/p/86251523e898" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/86251523e898<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ol start="4"><li><p>在 index.js 中定义格式化时间的方法</p></li> <li><p>在 index.js 中定义转义 HTML 的方法</p></li> <li><p>在 index.js 中定义还原 HTML 的方法</p></li> <li><p>将不同的功能进行模块化拆分</p></li></ol> <p>① 将格式化时间的功能，拆分到 src -&gt; dateFormat.js 中</p> <p>② 将处理 HTML 字符串的功能，拆分到 src -&gt; htmlEscape.js 中</p> <p>③ 在 index.js 中，导入两个模块，得到需要向外共享的方法</p> <p>④ 在 index.js 中，使用 module.exports 把对应的方法共享出去</p> <ol start="8"><li>编写包的说明文档</li></ol> <p>包根目录中的 README.md 文件，是包的使用说明文档。通过它，我们可以事先把包的使用说明，以 markdown 的格式写出来，方便用户参考。</p> <p>README 文件中具体写什么内容，没有强制性的要求；只要能够清晰地把包的作用、用法、注意事项等描述清楚即可。</p> <p>我们所创建的这个包的 README.md 文档中，会包含以下 6 项内容：</p> <p>安装方式、导入方式、格式化时间、转义 HTML 中的特殊字符、还原 HTML 中的特殊字符、开源协议</p> <h4 id="_8-发布包"><a href="#_8-发布包" class="header-anchor">#</a> 8.发布包</h4> <ol><li>注册 npm 账号</li></ol> <p>① 访问 <a href="https://www.npmjs.com/" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 网站，点击 sign up 按钮，进入注册用户界面</p> <p>② 填写账号相关的信息：Full Name、Public Email、Username、Password</p> <p>③ 点击 Create an Account 按钮，注册账号</p> <p>④ 登录邮箱，点击验证链接，进行账号的验证</p> <ol start="2"><li>登录 npm 账号</li></ol> <p>npm 账号注册完成后，可以在终端中执行 npm login 命令，依次输入用户名、密码、邮箱后，即可登录成功。</p> <p>注意：在运行 npm login 命令之前，必须先把下包的服务器地址切换为 npm 的官方服务器。否则会导致发布包失败！</p> <ol start="3"><li>把包发布到 npm 上</li></ol> <p>将终端切换到包的根目录之后，运行 npm publish 命令，即可将包发布到 npm 上（注意：包名不能雷同）。</p> <ol start="4"><li>删除已发布的包</li></ol> <p>运行 npm unpublish 包名 --force 命令，即可从 npm 删除已发布的包。</p> <p>注意：</p> <p>① npm unpublish 命令只能删除 72 小时以内发布的包</p> <p>② npm unpublish 删除的包，在 24 小时内不允许重复发布</p> <p>③ 发布包的时候要慎重，尽量不要往 npm 上发布没有意义的包！</p> <h3 id="_5-4-模块的加载机制"><a href="#_5-4-模块的加载机制" class="header-anchor">#</a> 5.4 模块的加载机制</h3> <h4 id="_1-优先从缓存中加载"><a href="#_1-优先从缓存中加载" class="header-anchor">#</a> 1.优先从缓存中加载</h4> <p>模块在第一次加载后会被缓存。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。</p> <p>注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。</p> <h4 id="_2-内置模块的加载机制"><a href="#_2-内置模块的加载机制" class="header-anchor">#</a> 2.内置模块的加载机制</h4> <p>内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。</p> <p>例如，require('fs') 始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs。</p> <h4 id="_3-自定义模块的加载机制"><a href="#_3-自定义模块的加载机制" class="header-anchor">#</a> 3.自定义模块的加载机制</h4> <p>使用 require() 加载自定义模块时，必须指定以 ./ 或 ../ 开头的路径标识符。在加载自定义模块时，如果没有指定 ./ 或 ../</p> <p>这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。</p> <p>同时，在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件：</p> <p>① 按照确切的文件名进行加载</p> <p>② 补全 .js 扩展名进行加载</p> <p>③ 补全 .json 扩展名进行加载</p> <p>④ 补全 .node 扩展名进行加载</p> <p>⑤ 加载失败，终端报错</p> <h4 id="_4-第三方模块的加载机制"><a href="#_4-第三方模块的加载机制" class="header-anchor">#</a> 4.第三方模块的加载机制</h4> <p>如果传递给 require() 的模块标识符不是一个内置模块，也没有以 ‘./’ 或 ‘../’ 开头，则 Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块。</p> <p>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。</p> <p>例如，假设在 'C:\Users\itheima\project\foo.js' 文件里调用了 require('tools')，则 Node.js 会按以下顺序查找：</p> <p>① C:\Users\itheima\project\node_modules\tools</p> <p>② C:\Users\itheima\node_modules\tools</p> <p>③ C:\Users\node_modules\tools</p> <p>④ C:\node_modules\tools</p> <h4 id="_5-目录作为模块"><a href="#_5-目录作为模块" class="header-anchor">#</a> 5.目录作为模块</h4> <p>当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式：</p> <p>① 在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口</p> <p>② 如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。</p> <p>③ 如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module 'xxx'</p> <h2 id="_6-express"><a href="#_6-express" class="header-anchor">#</a> 6.Express</h2> <h3 id="_6-1初始express"><a href="#_6-1初始express" class="header-anchor">#</a> 6.1初始Express</h3> <h4 id="_1-express-简介"><a href="#_1-express-简介" class="header-anchor">#</a> 1.Express 简介</h4> <ol><li>什么是 Express
官方给出的概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。</li></ol> <p>通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。</p> <p>Express 的本质：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。</p> <p>Express 的中文官网： <a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener noreferrer">http://www.expressjs.com.cn/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ol start="2"><li>进一步理解 Express
思考：不使用 Express 能否创建 Web 服务器？</li></ol> <p>答案：能，使用 Node.js 提供的原生 http 模块即可。</p> <p>思考：既生瑜何生亮（有了 http 内置模块，为什么还有用 Express）？</p> <p>答案：http 内置模块用起来很复杂，开发效率低；Express 是基于内置的 http 模块进一步封装出来的，能够极大的提高开发效率。</p> <p>思考：http 内置模块与 Express 是什么关系？</p> <p>答案：类似于浏览器中 Web API 和 jQuery 的关系。后者是基于前者进一步封装出来的。</p> <ol start="3"><li>Express 能做什么
对于前端程序员来说，最常见的两种服务器，分别是：</li></ol> <ul><li>Web 网站服务器：专门对外提供 Web 网页资源的服务器。
写的网页一般部署到web网站服务器上来对外提供web服务。</li> <li>API 接口服务器：专门对外提供 API 接口的服务器。</li></ul> <p>使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器</p> <h4 id="_2-express-的基本使用"><a href="#_2-express-的基本使用" class="header-anchor">#</a> 2.Express 的基本使用</h4> <ol><li>安装
在项目所处的目录中，运行如下的终端命令，即可将 express 安装到项目中使用：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>npm i express@4.17.1
</code></pre></div><ol start="2"><li>创建基本的 Web 服务器</li> <li>监听 GET 请求
通过 app.get() 方法，可以监听客户端的 GET 请求，具体的语法格式如下</li> <li>监听 POST 请求
通过 app.post() 方法，可以监听客户端的 POST 请求，具体的语法格式如下：</li> <li>把内容响应给客户端
通过 res.send() 方法，可以把处理好的内容，发送给客户端</li> <li>获取 URL 中携带的查询参数
通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数</li> <li>获取 URL 中的动态参数
通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// 1. 导入 express
const express = require('express')
// 2. 创建 web 服务器
const app = express()

// 4. 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容
app.get('/user', (req, res) =&gt; {
  // 调用 express 提供的 res.send() 方法，向客户端响应一个 JSON 对象
  res.send({ name: 'zs', age: 20, gender: '男' })
})
app.post('/user', (req, res) =&gt; {
  // 调用 express 提供的 res.send() 方法，向客户端响应一个 文本字符串
  res.send('请求成功')
})
app.get('/', (req, res) =&gt; {
  // 通过 req.query 可以获取到客户端发送过来的 查询参数
  // 注意：默认情况下，req.query 是一个空对象
  console.log(req.query)
  res.send(req.query)
})
// 注意：这里的 :id 是一个动态的参数
app.get('/user/:ids/:username', (req, res) =&gt; {
  // req.params 是动态匹配到的 URL 参数，默认也是一个空对象
  console.log(req.params)
  res.send(req.params)
})

// 3. 启动 web 服务器
app.listen(80, () =&gt; {
  console.log('express server running at http://127.0.0.1')
})
</code></pre></div><h4 id="_3-托管静态资源"><a href="#_3-托管静态资源" class="header-anchor">#</a> 3. 托管静态资源</h4> <ol><li>express.static()
express 提供了一个非常好用的函数，叫做 express.static()，通过它，我们可以非常方便地创建一个静态资源服务器，
例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>app.use(express.static('public'))
</code></pre></div><p>现在，你就可以访问 public 目录中的所有文件了：
http://localhost:3000/images/bg.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/login.js</p> <p>注意：Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在 URL 中。</p> <h3 id="_6-2-express-路由"><a href="#_6-2-express-路由" class="header-anchor">#</a> 6.2 Express 路由</h3> <h3 id="_6-3-express-中间件"><a href="#_6-3-express-中间件" class="header-anchor">#</a> 6.3 Express 中间件</h3> <h3 id="_6-4-使用-express-写接口"><a href="#_6-4-使用-express-写接口" class="header-anchor">#</a> 6.4 使用 Express 写接口</h3></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.74c4e6cc.js" defer></script><script src="/assets/js/3.a5e28c40.js" defer></script>
  </body>
</html>
